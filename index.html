<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>3D Water Simulation</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(#0a2342, #02101f);
    font-family: Arial, sans-serif;
  }

  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.45);
    padding: 12px;
    border-radius: 10px;
    color: #fff;
    z-index: 10;
  }

  #ui label {
    font-size: 13px;
  }

  #ui input {
    width: 140px;
  }
</style>
</head>
<body>

<div id="ui">
  <label>Sóng cao</label><br>
  <input id="waveHeight" type="range" min="0" max="3" step="0.05" value="1"><br><br>

  <label>Gió</label><br>
  <input id="wind" type="range" min="0" max="3" step="0.05" value="1"><br><br>

  <label>Tốc độ sóng</label><br>
  <input id="speed" type="range" min="0" max="4" step="0.05" value="1">
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js";

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a2342);

// Camera cố định từ trên xuống
const camera = new THREE.PerspectiveCamera(
  55,
  window.innerWidth / window.innerHeight,
  0.1,
  500
);
camera.position.set(0, 45, 0);
camera.lookAt(0, 0, 0);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Ánh sáng
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.DirectionalLight(0xffffff, 0.8);
light.position.set(20, 40, 10);
scene.add(light);

// Geometry mặt nước
const size = 80;
const segments = 180;
const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
geometry.rotateX(-Math.PI / 2);

// Shader
const material = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uWaveHeight: { value: 1 },
    uWind: { value: 1 },
    uSpeed: { value: 1 },
    uPulseCenter: { value: new THREE.Vector2(9999, 9999) },
    uPulseTime: { value: -10 }
  },
  vertexShader: `
    uniform float uTime;
    uniform float uWaveHeight;
    uniform float uWind;
    uniform float uSpeed;
    uniform vec2 uPulseCenter;
    uniform float uPulseTime;

    varying float vHeight;

    void main() {
      vec3 pos = position;

      float wave =
        sin((pos.x + uTime * uSpeed) * 0.4 * uWind) +
        cos((pos.z + uTime * uSpeed) * 0.35 * uWind);

      float dist = distance(pos.xz, uPulseCenter);
      float pulse =
        sin(dist * 1.5 - (uTime - uPulseTime) * 8.0) *
        exp(-dist * 0.08) * 3.0;

      if (uTime - uPulseTime > 3.0) pulse = 0.0;

      pos.y += wave * uWaveHeight + pulse;
      vHeight = pos.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    varying float vHeight;
    void main() {
      vec3 deep = vec3(0.0, 0.2, 0.45);
      vec3 light = vec3(0.2, 0.6, 1.0);
      float h = clamp(vHeight * 0.15 + 0.5, 0.0, 1.0);
      gl_FragColor = vec4(mix(deep, light, h), 1.0);
    }
  `
});

const water = new THREE.Mesh(geometry, material);
scene.add(water);

// UI controls
const waveHeight = document.getElementById("waveHeight");
const wind = document.getElementById("wind");
const speed = document.getElementById("speed");

// Click tạo sóng
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const hit = raycaster.intersectObject(water);
  if (hit.length) {
    material.uniforms.uPulseCenter.value.set(
      hit[0].point.x,
      hit[0].point.z
    );
    material.uniforms.uPulseTime.value = clock.getElapsedTime();
  }
});

// Sóng ngẫu nhiên 2 cái / giây
setInterval(() => {
  material.uniforms.uPulseCenter.value.set(
    (Math.random() - 0.5) * size,
    (Math.random() - 0.5) * size
  );
  material.uniforms.uPulseTime.value = clock.getElapsedTime();
}, 500);

// Resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animate
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);

  material.uniforms.uTime.value = clock.getElapsedTime();
  material.uniforms.uWaveHeight.value = waveHeight.value;
  material.uniforms.uWind.value = wind.value;
  material.uniforms.uSpeed.value = speed.value;

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
