<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>My Discord Profile</title>

<link rel="icon" href="https://discord.com/assets/847541504914fd33810e70a0ea73177e.ico">
<link rel="stylesheet" href="style.css">

<style>
#water-bg{
  position:fixed;
  inset:0;
  z-index:-10;
  display:none;
}

#water-controls{
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  display:none;
  gap:12px;
  padding:12px 16px;
  background:rgba(0,0,0,.45);
  border-radius:14px;
  color:#fff;
  z-index:20;
  align-items:center;
  font-size:12px;
}

#water-controls label{
  display:flex;
  flex-direction:column;
  gap:4px;
}

#water-controls input[type=range]{width:110px}

#water-controls button{
  background:#2b7cff;
  color:#fff;
  border:none;
  padding:6px 14px;
  border-radius:8px;
  cursor:pointer;
  font-weight:bold;
}
</style>
</head>

<body>

<canvas id="water-bg"></canvas>

<div id="water-controls">
  <label>ƒê·ªô cao s√≥ng
    <input id="waveHeight" type="range" min="0" max="4" step="0.1" value="1.8">
  </label>
  <label>Gi√≥
    <input id="waveSpeed" type="range" min="0" max="3" step="0.1" value="1">
  </label>
  <label>M√†u s√≥ng
    <input id="waveColor" type="color" value="#2b8cff">
  </label>
  <button id="pulseBtn">üåä T·∫°o s√≥ng</button>
</div>

<!-- LOGIN / PROFILE GI·ªÆ NGUY√äN -->
<script src="script.js"></script>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

/* ===== ELEMENTS ===== */
const canvas   = document.getElementById("water-bg");
const controls = document.getElementById("water-controls");

const waveHeightEl = document.getElementById("waveHeight");
const waveSpeedEl  = document.getElementById("waveSpeed");
const waveColorEl  = document.getElementById("waveColor");
const pulseBtnEl   = document.getElementById("pulseBtn");

/* ===== SCENE ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000814);

const renderer = new THREE.WebGLRenderer({canvas,alpha:true,antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);

/* ===== PARAMS ===== */
const params={
  waveHeight:1.8,
  waveSpeed:1,
  waveFreq:0.05,
  pulseStrength:3,
  tilt:0.25
};

const SIZE=200;
const geo=new THREE.PlaneGeometry(SIZE,SIZE,256,256);
geo.rotateX(-Math.PI/2);

/* ===== UNIFORMS ===== */
const pulses=[];
const uniforms={
  uTime:{value:0},
  uPulseTime:{value:-100},
  uPulseCenter:{value:new THREE.Vector2()},
  uPulseStrength:{value:params.pulseStrength},
  uWaveHeight:{value:params.waveHeight},
  uWaveSpeed:{value:params.waveSpeed},
  uWaveFreq:{value:params.waveFreq},
  uWaveColor:{value:new THREE.Color("#2b8cff")}
};

/* ===== MATERIAL ===== */
const mat=new THREE.ShaderMaterial({
  uniforms,
  vertexShader:`
  uniform float uTime,uWaveHeight,uWaveSpeed,uWaveFreq,uPulseTime,uPulseStrength;
  uniform vec2 uPulseCenter;
  varying float vH;
  void main(){
    vec3 p=position;
    float base=sin(p.x*uWaveFreq+uTime*uWaveSpeed)
             +cos(p.z*uWaveFreq+uTime*uWaveSpeed);
    float d=distance(p.xz,uPulseCenter);
    float pulse=sin(d*1.5-(uTime-uPulseTime)*8.0)
                *exp(-d*0.08)*uPulseStrength;
    p.y+=base*uWaveHeight+pulse;
    vH=p.y;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
  }`,
  fragmentShader:`
  uniform vec3 uWaveColor;
  varying float vH;
  void main(){
    vec3 deep=vec3(0.,.18,.3);
    float h=clamp((vH+3.)/6.,0.,1.);
    gl_FragColor=vec4(mix(deep,uWaveColor,h),1.);
  }`,
  side:THREE.DoubleSide
});

const water=new THREE.Mesh(geo,mat);
scene.add(water);

/* ===== CAMERA ===== */
const cam=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,.1,1000);
const BASE=SIZE*.9;
cam.position.set(0,BASE,0);
cam.up.set(0,0,-1);
cam.lookAt(0,0,0);

/* ===== TILT ===== */
let tx=0,tz=0,cx=0,cz=0;
addEventListener("mousemove",e=>{
  tz=(e.clientX/innerWidth-.5)*2*params.tilt;
  tx=(e.clientY/innerHeight-.5)*2*params.tilt;
});

/* ===== PULSE ===== */
function addPulse(x,z){
  pulses.push({x,z,start:uniforms.uTime.value,life:2+Math.random()});
}

renderer.domElement.addEventListener("click",e=>{
  const r=renderer.domElement.getBoundingClientRect();
  const x=((e.clientX-r.left)/r.width)*2-1;
  const y=-((e.clientY-r.top)/r.height)*2+1;
  const ray=new THREE.Raycaster();
  ray.setFromCamera({x,y},cam);
  const hit=ray.intersectObject(water);
  if(hit[0]) addPulse(hit[0].point.x,hit[0].point.z);
});

setInterval(()=>{
  for(let i=0;i<2;i++)
    addPulse((Math.random()-.5)*SIZE,(Math.random()-.5)*SIZE);
},1000);

/* ===== CONTROLS (ƒê√É FIX) ===== */
waveHeightEl.addEventListener("input",e=>{
  uniforms.uWaveHeight.value=parseFloat(e.target.value);
});

waveSpeedEl.addEventListener("input",e=>{
  uniforms.uWaveSpeed.value=parseFloat(e.target.value);
});

waveColorEl.addEventListener("input",e=>{
  uniforms.uWaveColor.value.set(e.target.value);
});

pulseBtnEl.addEventListener("click",()=>{
  addPulse(0,0);
});

/* ===== LOOP ===== */
function loop(t){
  requestAnimationFrame(loop);
  uniforms.uTime.value=t*.001;

  for(let i=pulses.length-1;i>=0;i--)
    if(uniforms.uTime.value-pulses[i].start>pulses[i].life)
      pulses.splice(i,1);

  if(pulses[0]){
    uniforms.uPulseCenter.value.set(pulses[0].x,pulses[0].z);
    uniforms.uPulseTime.value=pulses[0].start;
  }else uniforms.uPulseTime.value=-100;

  cx+=(tx-cx)*.05;
  cz+=(tz-cz)*.05;
  cam.position.set(cz*30,BASE,-cx*30);
  cam.lookAt(0,0,0);

  renderer.render(scene,cam);
}
loop(0);

/* ===== SHOW AFTER LOGIN ===== */
new MutationObserver(()=>{
  const card=document.getElementById("profile-card");
  if(card && !card.classList.contains("hidden")){
    canvas.style.display="block";
    controls.style.display="flex";
  }
}).observe(document.getElementById("profile-card"),{attributes:true});

addEventListener("resize",()=>{
  cam.aspect=innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
