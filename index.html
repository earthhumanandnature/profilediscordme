<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>3D Water Simulation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: linear-gradient(#0a2a43, #000814);
      font-family: Arial;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.45);
      padding: 10px;
      border-radius: 8px;
      color: #fff;
      z-index: 10;
    }

    #ui label {
      font-size: 13px;
      display: block;
      margin-top: 6px;
    }

    input[type="range"] {
      width: 180px;
    }
  </style>
</head>
<body>

<div id="ui">
  <label>Độ cao sóng</label>
  <input id="waveHeight" type="range" min="0" max="3" step="0.1" value="1">

  <label>Tốc độ sóng</label>
  <input id="waveSpeed" type="range" min="0" max="5" step="0.1" value="1.5">

  <label>Gió</label>
  <input id="windStrength" type="range" min="0" max="5" step="0.1" value="1">
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

// Góc nhìn từ trên xuống – cố định
camera.position.set(0, 35, 0);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0);
document.body.appendChild(renderer.domElement);

// ===== WATER PLANE =====
const geometry = new THREE.PlaneGeometry(60, 60, 200, 200);

const material = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uWaveHeight: { value: 1 },
    uWaveSpeed: { value: 1.5 },
    uWind: { value: 1 },
    uPulseCenter: { value: new THREE.Vector2(0, 0) },
    uPulseTime: { value: -100 }
  },
  vertexShader: `
    uniform float uTime;
    uniform float uWaveHeight;
    uniform float uWaveSpeed;
    uniform float uWind;
    uniform vec2 uPulseCenter;
    uniform float uPulseTime;

    varying float vWave;

    void main() {
      vec3 pos = position;

      float wave =
        sin(pos.x * 0.25 + uTime * uWaveSpeed) +
        cos(pos.y * 0.35 + uTime * (uWaveSpeed + uWind));

      float pulseDist = distance(pos.xy, uPulseCenter);
      float pulse =
        sin(pulseDist * 1.8 - (uTime - uPulseTime) * 8.0)
        * exp(-pulseDist * 0.08)
        * 3.0;

      pos.z += wave * uWaveHeight + pulse;

      vWave = pos.z;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  `,
  fragmentShader: `
    varying float vWave;
    void main() {
      float colorShift = clamp(vWave * 0.15 + 0.4, 0.0, 1.0);
      vec3 waterColor = mix(
        vec3(0.0, 0.3, 0.6),
        vec3(0.2, 0.8, 1.0),
        colorShift
      );
      gl_FragColor = vec4(waterColor, 1.0);
    }
  `,
  side: THREE.DoubleSide
});

const water = new THREE.Mesh(geometry, material);
water.rotation.x = -Math.PI / 2;
scene.add(water);

// ===== UI CONTROL =====
const waveHeightInput = document.getElementById("waveHeight");
const waveSpeedInput = document.getElementById("waveSpeed");
const windInput = document.getElementById("windStrength");

waveHeightInput.oninput = () =>
  material.uniforms.uWaveHeight.value = +waveHeightInput.value;

waveSpeedInput.oninput = () =>
  material.uniforms.uWaveSpeed.value = +waveSpeedInput.value;

windInput.oninput = () =>
  material.uniforms.uWind.value = +windInput.value;

// ===== CLICK TẠO SÓNG =====
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(water);

  if (intersects.length > 0) {
    const p = intersects[0].point;
    material.uniforms.uPulseCenter.value.set(p.x, p.z);
    material.uniforms.uPulseTime.value = material.uniforms.uTime.value;
  }
});

// ===== SÓNG NGẪU NHIÊN (2 / GIÂY) =====
setInterval(() => {
  const x = (Math.random() - 0.5) * 40;
  const y = (Math.random() - 0.5) * 40;
  material.uniforms.uPulseCenter.value.set(x, y);
  material.uniforms.uPulseTime.value = material.uniforms.uTime.value;
}, 500);

// ===== LOOP =====
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += clock.getDelta();
  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
