<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>3D Water Simulation (Top-down Fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Import map để trình duyệt hiểu "three" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<script type="module">
import * as THREE from 'three';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

const waterContainer = document.getElementById('water-bg');

/* ========== SCENE ========= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000814);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
waterContainer.appendChild(renderer.domElement);

/* ========== PARAMS ========= */
const params = {
  waveHeight: 1.8,
  waveSpeed: 1.0,
  waveFreq: 0.05,
  pulseStrength: 3.5,
  pulseDuration: 2.5, // ⏱ thời gian tồn tại sóng (giây)
  tiltStrength: 0.25
};

/* ========== WATER ========= */
const SIZE = 200;
const geo = new THREE.PlaneGeometry(SIZE, SIZE, 256, 256);
geo.rotateX(-Math.PI / 2);

const uniforms = {
  uTime: { value: 0 },
  uPulseTime: { value: -10 },
  uPulseDuration: { value: params.pulseDuration },
  uPulseCenter: { value: new THREE.Vector2(0,0) },
  uWaveHeight: { value: params.waveHeight },
  uWaveSpeed: { value: params.waveSpeed },
  uWaveFreq: { value: params.waveFreq },
  uPulseStrength: { value: params.pulseStrength }
};

const mat = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    uniform float uTime;
    uniform float uWaveHeight;
    uniform float uWaveSpeed;
    uniform float uWaveFreq;

    uniform float uPulseTime;
    uniform float uPulseDuration;
    uniform float uPulseStrength;
    uniform vec2 uPulseCenter;

    varying float vH;

    void main(){
      vec3 p = position;

      float baseWave =
        sin(p.x * uWaveFreq + uTime * uWaveSpeed) +
        cos(p.z * uWaveFreq + uTime * uWaveSpeed);

      float pulse = 0.0;
      float life = uTime - uPulseTime;

      if(life > 0.0 && life < uPulseDuration){
        float d = distance(p.xz, uPulseCenter);
        float fade = 1.0 - (life / uPulseDuration);
        pulse =
          sin(d * 1.5 - life * 8.0) *
          exp(-d * 0.08) *
          uPulseStrength *
          fade;
      }

      p.y += baseWave * uWaveHeight + pulse;
      vH = p.y;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }
  `,
  fragmentShader: `
    varying float vH;
    void main(){
      vec3 deep = vec3(0.0,0.18,0.3);
      vec3 shallow = vec3(0.35,0.65,1.0);
      float h = clamp((vH + 3.0)/6.0,0.0,1.0);
      gl_FragColor = vec4(mix(deep,shallow,h),1.0);
    }
  `,
  side: THREE.DoubleSide
});

const water = new THREE.Mesh(geo, mat);
scene.add(water);

/* ========== CAMERA ========= */
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const BASE_Y = SIZE * 0.9;
camera.position.set(0, BASE_Y, 0);
camera.up.set(0,0,-1);
camera.lookAt(0,0,0);

/* ========== SMOOTH TILT ========= */
let targetX=0,targetZ=0,curX=0,curZ=0;
addEventListener('mousemove',e=>{
  const nx=(e.clientX/innerWidth-0.5)*2;
  const ny=(e.clientY/innerHeight-0.5)*2;
  targetX = ny * params.tiltStrength;
  targetZ = nx * params.tiltStrength;
});

/* ========== CLICK → PULSE ========= */
renderer.domElement.addEventListener('click',e=>{
  const r=renderer.domElement.getBoundingClientRect();
  const x=((e.clientX-r.left)/r.width)*2-1;
  const y=-((e.clientY-r.top)/r.height)*2+1;
  const ray=new THREE.Raycaster();
  ray.setFromCamera({x,y},camera);
  const hit=ray.intersectObject(water);
  if(hit[0]){
    uniforms.uPulseCenter.value.set(hit[0].point.x,hit[0].point.z);
    uniforms.uPulseTime.value = uniforms.uTime.value;
  }
});

/* ========== GUI ========= */
const gui=new GUI();
gui.add(params,'waveHeight',0,4).onChange(v=>uniforms.uWaveHeight.value=v);
gui.add(params,'waveSpeed',0,3).onChange(v=>uniforms.uWaveSpeed.value=v);
gui.add(params,'waveFreq',0.01,0.2).onChange(v=>uniforms.uWaveFreq.value=v);
gui.add(params,'pulseStrength',0,6).onChange(v=>uniforms.uPulseStrength.value=v);
gui.add(params,'pulseDuration',1,4).onChange(v=>uniforms.uPulseDuration.value=v);
gui.add(params,'tiltStrength',0,0.6);

/* ========== LOOP ========= */
function animate(t){
  requestAnimationFrame(animate);
  uniforms.uTime.value = t*0.001;

  curX += (targetX-curX)*0.05;
  curZ += (targetZ-curZ)*0.05;

  camera.position.x = curZ*30;
  camera.position.z = -curX*30;
  camera.position.y = BASE_Y;
  camera.lookAt(0,0,0);

  renderer.render(scene,camera);
}
animate(0);

/* ========== SHOW AFTER LOGIN ========= */
const obs=new MutationObserver(()=>{
  if(!document.getElementById('profile-card').classList.contains('hidden')){
    waterContainer.style.display='block';
  }
});
obs.observe(document.getElementById('profile-card'),{attributes:true});

/* ========== RESIZE ========= */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
