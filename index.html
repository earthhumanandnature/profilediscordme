<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Discord Profile</title>

  <link rel="icon" href="https://discord.com/assets/847541504914fd33810e70a0ea73177e.ico">
  <link rel="stylesheet" href="style.css">

  <style>
    #water-bg {
      position: fixed;
      inset: 0;
      z-index: -10;
      display: none;
    }

    #water-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 12px;
      padding: 12px 16px;
      background: rgba(0,0,0,0.45);
      border-radius: 14px;
      color: #fff;
      z-index: 20;
      align-items: center;
      font-size: 12px;
    }

    #water-controls label {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #water-controls input[type="range"] {
      width: 110px;
    }

    #water-controls button {
      background: #2b7cff;
      color: #fff;
      border: none;
      padding: 6px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>

<canvas id="water-bg"></canvas>

<div id="water-controls">
  <label>ƒê·ªô cao s√≥ng
    <input id="waveHeight" type="range" min="0" max="3" step="0.1" value="1.2">
  </label>
  <label>Gi√≥
    <input id="waveSpeed" type="range" min="0" max="4" step="0.1" value="1.5">
  </label>
  <label>M√†u s√≥ng
    <input id="waveColor" type="color" value="#2b8cff">
  </label>
  <button id="pulseBtn">üåä T·∫°o s√≥ng</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

const waterCanvas = document.getElementById('water-bg');

/* ===== SCENE ===== */
const scene = new THREE.Scene();

const renderer = new THREE.WebGLRenderer({
  canvas: waterCanvas,
  antialias: true,
  alpha: true
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);

/* ===== PARAMS ===== */
const params = {
  waveHeight: 1.2,
  waveSpeed: 1.5,
  waveFreq: 0.05,
  pulseStrength: 3.0,
  tiltStrength: 0.25
};

/* ===== WATER ===== */
const SIZE = 200;
const geo = new THREE.PlaneGeometry(SIZE, SIZE, 256, 256);
geo.rotateX(-Math.PI / 2);

const pulses = [];

const uniforms = {
  uTime: { value: 0 },
  uPulseTime: { value: -100 },
  uPulseCenter: { value: new THREE.Vector2() },
  uPulseStrength: { value: params.pulseStrength },
  uWaveHeight: { value: params.waveHeight },
  uWaveSpeed: { value: params.waveSpeed },
  uWaveFreq: { value: params.waveFreq },
  uWaveColor: { value: new THREE.Color("#2b8cff") }
};

const mat = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    uniform float uTime;
    uniform float uWaveHeight;
    uniform float uWaveSpeed;
    uniform float uWaveFreq;
    uniform float uPulseTime;
    uniform float uPulseStrength;
    uniform vec2 uPulseCenter;
    varying float vH;

    void main(){
      vec3 p = position;

      float base =
        sin(p.x * uWaveFreq + uTime * uWaveSpeed) +
        cos(p.z * uWaveFreq + uTime * uWaveSpeed);

      float d = distance(p.xz, uPulseCenter);
      float pulse =
        sin(d * 1.5 - (uTime - uPulseTime) * 8.0)
        * exp(-d * 0.08)
        * uPulseStrength;

      p.y += base * uWaveHeight + pulse;
      vH = p.y;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 uWaveColor;
    varying float vH;

    void main(){
      vec3 deep = vec3(0.0,0.15,0.3);
      float h = clamp((vH + 3.0)/6.0,0.0,1.0);
      gl_FragColor = vec4(mix(deep, uWaveColor, h), 1.0);
    }
  `,
  side: THREE.DoubleSide
});

const water = new THREE.Mesh(geo, mat);
scene.add(water);

/* ===== CAMERA ===== */
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const BASE_Y = SIZE * 0.9;
camera.position.set(0, BASE_Y, 0);
camera.up.set(0,0,-1);
camera.lookAt(0,0,0);

/* ===== SMOOTH TILT ===== */
let targetX=0,targetZ=0,curX=0,curZ=0;
addEventListener('mousemove',e=>{
  targetZ = (e.clientX/innerWidth - 0.5)*2*params.tiltStrength;
  targetX = (e.clientY/innerHeight - 0.5)*2*params.tiltStrength;
});

/* ===== PULSE ===== */
function addPulse(x,z){
  pulses.push({ x,z, start: uniforms.uTime.value, life: 2 + Math.random() });
}

renderer.domElement.addEventListener('click',e=>{
  const r = renderer.domElement.getBoundingClientRect();
  const x = ((e.clientX-r.left)/r.width)*2-1;
  const y = -((e.clientY-r.top)/r.height)*2+1;
  const ray = new THREE.Raycaster();
  ray.setFromCamera({x,y},camera);
  const hit = ray.intersectObject(water);
  if(hit[0]) addPulse(hit[0].point.x, hit[0].point.z);
});

setInterval(()=>{
  for(let i=0;i<2;i++){
    addPulse((Math.random()-0.5)*SIZE,(Math.random()-0.5)*SIZE);
  }
},1000);

/* ===== HTML CONTROLS ===== */
waveHeight.oninput = () => uniforms.uWaveHeight.value = +waveHeight.value;
waveSpeed.oninput  = () => uniforms.uWaveSpeed.value  = +waveSpeed.value;
waveColor.oninput  = () => uniforms.uWaveColor.value.set(waveColor.value);
pulseBtn.onclick   = () => addPulse(0,0);

/* ===== LOOP ===== */
function animate(t){
  requestAnimationFrame(animate);
  uniforms.uTime.value = t*0.001;

  for(let i=pulses.length-1;i>=0;i--){
    if(uniforms.uTime.value - pulses[i].start > pulses[i].life){
      pulses.splice(i,1);
    }
  }

  if(pulses[0]){
    uniforms.uPulseCenter.value.set(pulses[0].x, pulses[0].z);
    uniforms.uPulseTime.value = pulses[0].start;
  } else {
    uniforms.uPulseTime.value = -100;
  }

  curX += (targetX-curX)*0.05;
  curZ += (targetZ-curZ)*0.05;
  camera.position.set(curZ*30, BASE_Y, -curX*30);
  camera.lookAt(0,0,0);

  renderer.render(scene,camera);
}
animate(0);

/* ===== SHOW AFTER LOGIN ===== */
new MutationObserver(()=>{
  const card = document.getElementById('profile-card');
  if(card && !card.classList.contains('hidden')){
    waterCanvas.style.display = 'block';
    document.getElementById('water-controls').style.display = 'flex';
  }
}).observe(document.getElementById('profile-card'), {attributes:true});

/* ===== RESIZE ===== */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>
